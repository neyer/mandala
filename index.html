<html>
    <head>
</style>

  <script src="http:///s3.neyer.me/js/jquery.min.js"></script>
  <script>
$(document).ready(function(){

    c = document.getElementById("draw-canvas");
    var ctx = c.getContext("2d");

    var lineBorder = 10;
    var CanvasWidth = 800, CanvasHeight = 800;
    var lineWidth = 20;
    var lineSpacing = 5;
    // 7 colors, but some are more bigger than others

    // overall animation cycle frequency
    var PulseInterval = 4000;


  // as the user clicks, we will add to this list
    var clickDurations = [];
    var maxIntervals = (CanvasWidth-lineBorder*2)/(lineWidth+lineSpacing) - 1;

    // first draw a box around it
    function drawBorder() {
      ctx.beginPath();
      ctx.moveTo(lineBorder, lineBorder);
      ctx.lineTo(CanvasWidth-lineBorder, lineBorder);
      ctx.lineTo(CanvasWidth-lineBorder, CanvasHeight-lineBorder);
      ctx.lineTo(lineBorder, CanvasHeight-lineBorder);
      ctx.closePath();
      ctx.stroke();
    };

    drawBorder();


    // the goal here is to draw some shapes of varying sizes
    // a large number of shapes with small sizes
    // and a small number of shapes with large sizes

    function clearBox() {
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fillRect(0,0,CanvasWidth,CanvasHeight);
    }

    var triangleHeight = CanvasHeight/(7*2);
    var triangleColor = "rgba(255,0,0,0.1)";
    function drawRedTriangle(timestamp) {
        // rotate according to the time
      // first clockwise triangle
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.rotate(Math.PI*2*timestamp/PulseInterval);
        ctx.beginPath();
        ctx.moveTo(0, - triangleHeight);
        // 30 degress in radians
        var angle = Math.PI/6.0;
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
        ctx.lineTo(triangleHeight*Math.cos(-angle), - triangleHeight*Math.sin(-angle));
        ctx.lineTo(triangleHeight*Math.cos(Math.PI+angle), - triangleHeight*Math.sin(Math.PI+angle));
         ctx.closePath();
         ctx.fillStyle = triangleColor;
         ctx.fill();
         ctx.resetTransform();

        // then counterclockwise
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.rotate(-Math.PI*2*timestamp/PulseInterval);
        ctx.beginPath();
        ctx.moveTo(0, - triangleHeight);
        // 30 degress in radians
        var angle = Math.PI/6.0;
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
        ctx.lineTo(triangleHeight*Math.cos(-angle), - triangleHeight*Math.sin(-angle));
        ctx.lineTo(triangleHeight*Math.cos(Math.PI+angle), - triangleHeight*Math.sin(Math.PI+angle));
         ctx.closePath();
         ctx.fillStyle = triangleColor;
         ctx.fill();
         ctx.resetTransform();

      
    }


    // Orange Squares moving around the points of a triangle
    var squareSize = triangleHeight/3;

    var UP = 0, RIGHT = 1, DOWN = 2, LEFT = 3;
    var squares = [
    ]

    function addSquaresAtScale(scale) {
      var alpha = Math.min(1-0.5*scale, 1);
      squares.push(
      {
        'pos' :[-squareSize, -squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': RIGHT,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[squareSize, -squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': DOWN,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[squareSize, squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': LEFT,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[-squareSize, squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': UP,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
    }

    addSquaresAtScale(1.0);
    addSquaresAtScale(3.0/4.0);
    addSquaresAtScale(1/2);
    addSquaresAtScale(1/4);
    addSquaresAtScale(1/5);
    addSquaresAtScale(1/8);

    function updateSquare(square, timestamp) {
     var deltaT = timestamp - square.lastUpdateTicks;
       switch (square.dir) {
          case UP:
            square.pos[1] = square.pos[1]-square.moveSpeed*(deltaT/1000);
            if (square.pos[1] < -square.range) {
              square.pos[1] = -square.range;
              square.dir = RIGHT;
            }

            break;
          case RIGHT:
            square.pos[0] = square.pos[0]+square.moveSpeed*(deltaT/1000);
            if (square.pos[0] > square.range) {
              square.pos[0] = square.range;
              square.dir = DOWN;
            }
            break;
          case DOWN:
            square.pos[1] = square.pos[1]+square.moveSpeed*(deltaT/1000);
            if (square.pos[1] > square.range) {
              square.pos[1] = square.range;
              square.dir = LEFT;
            }
            break;
          case LEFT:
            square.pos[0] = square.pos[0]-square.moveSpeed*(deltaT/1000);
            if (square.pos[0] < -square.range) {
              square.pos[0] = -square.range;
              square.dir = UP;
            }
            break;
        };
        square.lastUpdateTicks = timestamp;

    }
    
    function drawOrangeSquares(timestamp) {
        ctx.resetTransform();
        // rotate according to the time
        //ctx.rotate(-Math.PI*2*timestamp/PulseInterval);
        for (var squareNum = 0; squareNum < squares.length; ++squareNum) {
        var square = squares[squareNum];
        ctx.translate(CanvasWidth/2.0+square.pos[0], CanvasHeight/2.0+square.pos[1]);
        updateSquare(square, timestamp);
        // now move the square a long 
        ctx.beginPath();
        ctx.moveTo(-square.size, - square.size);
        ctx.lineTo(square.size, - square.size);
        ctx.lineTo(square.size, square.size);
        ctx.lineTo(-square.size, square.size);
        ctx.closePath();
        ctx.fillStyle = "rgba(252,107,3,"+square.alpha+")";
        ctx.fill();
        ctx.resetTransform();
      }
    }

    var starburstWidth = triangleHeight/10.0;
    var starburstHeight= triangleHeight*2.5;
    var starburstHeightVariance = starburstHeight*0.125;
    var numBursts = 32
    var starPulseInterval = PulseInterval/8.0;
    var numPulseWaves = 4;
    var starBrightColor = "rgb(253,255,117,0.8)";
    var starDarkColor = "rgb(255,163,117,0.8)";
    function drawYellowStarburst(timestamp) {
        // rotate according to the time
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        var grd = ctx.createRadialGradient(0,0, 0, 0,0, starburstHeight);
        grd.addColorStop(0, starBrightColor);
        var pulseStart = 
           (timestamp % starPulseInterval)/(starPulseInterval*(numPulseWaves));

        var pulseOffset = 1/numPulseWaves;
        for (var pulseWaveNo = 0; pulseWaveNo < numPulseWaves; ++pulseWaveNo) {
          grd.addColorStop(pulseStart, starDarkColor);
          var nextPulse = pulseStart+1/(2.0*numPulseWaves);
          if (nextPulse < 1) {
            grd.addColorStop(pulseStart+1/(2.0*numPulseWaves), starBrightColor);
          }
          pulseStart = pulseStart + pulseOffset;
       } 

        grd.addColorStop(1, starBrightColor);



        var angle = 2*Math.PI/numBursts;
        for (var  i = 0; i < numBursts; ++i) {
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen

          ctx.beginPath();
          ctx.moveTo(-starburstWidth, 0);
          ctx.lineTo(0, starburstHeight);
          ctx.lineTo(starburstWidth, 0);
          ctx.closePath();
          ctx.fillStyle = grd; //"rgba(248,252,3,0.8)";
          ctx.fill();
          ctx.rotate(angle);
        }
        ctx.resetTransform();
    }


   var earthCoreRadius = triangleHeight*3;
   function drawBrownCircle(timestamp) {
         var grd = ctx.createRadialGradient(0,0, 0, 0,0, earthCoreRadius);
        grd.addColorStop(0, "rgb(50,0,0)");
        grd.addColorStop(1, "rgb(105,65,27");


        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  earthCoreRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }

    var numCircles = 128;
    var circleOffset = earthCoreRadius*1.1;
    var circleRadius = triangleHeight/8;
    var circles = [];

    for (var i = 0; i < numCircles; ++i) {
      var treeColorBase = {
        'r' :38, 'g': 99, 'b': 12
      }
      var fudgeColor = function (colorIndex) {
        var baseNum = treeColorBase[colorIndex];
        return  (Math.floor((baseNum + (baseNum * 0.2 * Math.random())))).toString();

      }
      circles.push({
        'phase': Math.random(),
        'color': ('rgb('+fudgeColor('r')+','+fudgeColor('g')+','+fudgeColor('b')+')')
      });
    }
    function drawGreenCircles(timestamp) {
        ctx.beginPath();
        // rotate according to the time
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);

        var angle = 2*Math.PI/numBursts;
        for (var  i = 0; i < numCircles; ++i) {
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
          var thisCircle = circles[i];
          var thisPhase =(thisCircle.phase+timestamp/(PulseInterval*4))*Math.PI*2;
          var thisSize = (1+Math.sin(thisPhase));
          ctx.beginPath();
          ctx.arc(0, circleOffset, thisSize*circleRadius, 0, 2*Math.PI);
          ctx.closePath();
          ctx.fillStyle = thisCircle.color;
          ctx.fill();
          ctx.rotate(angle);
          // grow this circle

        }
        ctx.resetTransform();
    }

   var atmosphereRadius = earthCoreRadius*2;
   var purpleOuterFringeColor = "rgba(48,3,252,0.2)";
   function drawBlueCircle(timestamp) {
        var grd = ctx.createRadialGradient(0,0, earthCoreRadius, 0,0, atmosphereRadius);
        grd.addColorStop(0, "skyblue");
        grd.addColorStop(1, purpleOuterFringeColor);

        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  atmosphereRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }


   var exosphereRadius = atmosphereRadius*1.1;
   function drawPurpleCircle(timestamp) {
        var grd = ctx.createRadialGradient(0,0, atmosphereRadius, 0,0, exosphereRadius);
        grd.addColorStop(0, purpleOuterFringeColor);
        grd.addColorStop(1, "black");
        
        // Fill with gradient
        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  exosphereRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }


    var numStars = 128;
    var starSpots = [];
    var starRadius = 2;
    for (var i = 0; i < numStars; ++i) {
      var x = Math.random()*CanvasWidth;
      var y = Math.random()*CanvasHeight;
      starSpots[i] = [x,y];
    }
    function drawStars() {
      for (var i = 0; i < starSpots.length; ++i) {
        // Fill with gradient
        ctx.resetTransform();
        ctx.translate(starSpots[i][0], starSpots[i][1]);
        ctx.beginPath();
        ctx.arc(0, 0,  starRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.resetTransform();
      }
    }


    var start = null;
    var breathTimeMs = 5000;
    var cycleTimeMs = breathTimeMs*4;
    function drawAll(timestamp) {
      // Draw in color-reverse order
      drawStars(timestamp);
      drawPurpleCircle(timestamp);
      drawBlueCircle(timestamp);
      drawGreenCircles(timestamp);
      drawBrownCircle(timestamp);
      drawYellowStarburst(timestamp);
      drawOrangeSquares(timestamp);
      drawRedTriangle(timestamp);
      //
        requestAnimationFrame(drawAll);
    }

  
  clearBox();
  window.requestAnimationFrame(drawAll);
  
    
});
</script>
</head>
<body>
  <canvas id="draw-canvas" width="800" height="800"></canvas>
</body>
</html>

