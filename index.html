<html>
    <head>
</style>

  <script src="http:///s3.neyer.me/js/jquery.min.js"></script>
  <script>
$(document).ready(function(){

    c = document.getElementById("draw-canvas");
    var ctx = c.getContext("2d");

    var lineBorder = 10;
    var CanvasWidth = 800, CanvasHeight = 800;
    var lineWidth = 20;
    var lineSpacing = 5;
    // 7 colors, but some are more bigger than others

    // overall animation cycle frequency
    var PulseInterval = 4000;


  // as the user clicks, we will add to this list
    var clickDurations = [];
    var maxIntervals = (CanvasWidth-lineBorder*2)/(lineWidth+lineSpacing) - 1;

    // first draw a box around it
    function drawBorder() {
      ctx.beginPath();
      ctx.moveTo(lineBorder, lineBorder);
      ctx.lineTo(CanvasWidth-lineBorder, lineBorder);
      ctx.lineTo(CanvasWidth-lineBorder, CanvasHeight-lineBorder);
      ctx.lineTo(lineBorder, CanvasHeight-lineBorder);
      ctx.closePath();
      ctx.stroke();
    };

    drawBorder();


    // the goal here is to draw some shapes of varying sizes
    // a large number of shapes with small sizes
    // and a small number of shapes with large sizes

    function clearBox() {
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fillRect(0,0,CanvasWidth,CanvasHeight);
    }

    var triangleHeight = CanvasHeight/(7*2);
    var triangleColor = "rgba(255,0,0,0.1)";
    function drawRedTriangle(timestamp) {
        // rotate according to the time
      // first clockwise triangle
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.rotate(Math.PI*2*timestamp/PulseInterval);
        ctx.beginPath();
        ctx.moveTo(0, - triangleHeight);
        // 30 degress in radians
        var angle = Math.PI/6.0;
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
        ctx.lineTo(triangleHeight*Math.cos(-angle), - triangleHeight*Math.sin(-angle));
        ctx.lineTo(triangleHeight*Math.cos(Math.PI+angle), - triangleHeight*Math.sin(Math.PI+angle));
         ctx.closePath();
         ctx.fillStyle = triangleColor;
         ctx.fill();
         ctx.resetTransform();

        // then counterclockwise
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.rotate(-Math.PI*2*timestamp/PulseInterval);
        ctx.beginPath();
        ctx.moveTo(0, - triangleHeight);
        // 30 degress in radians
        var angle = Math.PI/6.0;
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
        ctx.lineTo(triangleHeight*Math.cos(-angle), - triangleHeight*Math.sin(-angle));
        ctx.lineTo(triangleHeight*Math.cos(Math.PI+angle), - triangleHeight*Math.sin(Math.PI+angle));
         ctx.closePath();
         ctx.fillStyle = triangleColor;
         ctx.fill();
         ctx.resetTransform();

      
    }


    // Orange Squares moving around the points of a triangle
    var squareSize = triangleHeight/3;

    var UP = 0, RIGHT = 1, DOWN = 2, LEFT = 3;
    var squares = [
    ]

    function addSquaresAtScale(scale) {
      var alpha = Math.min(1-0.5*scale, 1);
      squares.push(
      {
        'pos' :[-squareSize, -squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': RIGHT,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[squareSize, -squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': DOWN,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[squareSize, squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': LEFT,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
      squares.push({
        'pos' :[-squareSize, squareSize],
        'size' : squareSize*scale,
        'alpha': alpha,
        'range' : squareSize*1.1,
        'dir': UP,
        'lastUpdateTicks' : 0,
        'moveSpeed' : squareSize/scale,
      });
    }

    addSquaresAtScale(1.0);
    addSquaresAtScale(3.0/4.0);
    addSquaresAtScale(1/2);
    addSquaresAtScale(1/4);
    addSquaresAtScale(1/5);
    addSquaresAtScale(1/8);

    function updateSquare(square, timestamp) {
     var deltaT = timestamp - square.lastUpdateTicks;
       switch (square.dir) {
          case UP:
            square.pos[1] = square.pos[1]-square.moveSpeed*(deltaT/1000);
            if (square.pos[1] < -square.range) {
              square.pos[1] = -square.range;
              square.dir = RIGHT;
            }

            break;
          case RIGHT:
            square.pos[0] = square.pos[0]+square.moveSpeed*(deltaT/1000);
            if (square.pos[0] > square.range) {
              square.pos[0] = square.range;
              square.dir = DOWN;
            }
            break;
          case DOWN:
            square.pos[1] = square.pos[1]+square.moveSpeed*(deltaT/1000);
            if (square.pos[1] > square.range) {
              square.pos[1] = square.range;
              square.dir = LEFT;
            }
            break;
          case LEFT:
            square.pos[0] = square.pos[0]-square.moveSpeed*(deltaT/1000);
            if (square.pos[0] < -square.range) {
              square.pos[0] = -square.range;
              square.dir = UP;
            }
            break;
        };
        square.lastUpdateTicks = timestamp;

    }
    
    function drawOrangeSquares(timestamp) {
        ctx.resetTransform();
        // rotate according to the time
        //ctx.rotate(-Math.PI*2*timestamp/PulseInterval);
        for (var squareNum = 0; squareNum < squares.length; ++squareNum) {
        var square = squares[squareNum];
        ctx.translate(CanvasWidth/2.0+square.pos[0], CanvasHeight/2.0+square.pos[1]);
        updateSquare(square, timestamp);
        // now move the square a long 
        ctx.beginPath();
        ctx.moveTo(-square.size, - square.size);
        ctx.lineTo(square.size, - square.size);
        ctx.lineTo(square.size, square.size);
        ctx.lineTo(-square.size, square.size);
        ctx.closePath();
        ctx.fillStyle = "rgba(252,107,3,"+square.alpha+")";
        ctx.fill();
        ctx.resetTransform();
      }
    }

    var starburstWidth = triangleHeight/10.0;
    var starburstHeight= triangleHeight*2.5;
    var starburstHeightVariance = starburstHeight*0.125;
    var numBursts = 32
    var starPulseInterval = PulseInterval/8.0;
    var numPulseWaves = 4;
    var starBrightColor = "rgb(253,255,117,0.8)";
    var starDarkColor = "rgb(255,163,117,0.8)";
    function drawYellowStarburst(timestamp) {
        // rotate according to the time
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        var grd = ctx.createRadialGradient(0,0, 0, 0,0, starburstHeight);
        grd.addColorStop(0, starBrightColor);
        var pulseStart = 
           (timestamp % starPulseInterval)/(starPulseInterval*(numPulseWaves));

        var pulseOffset = 1/numPulseWaves;
        for (var pulseWaveNo = 0; pulseWaveNo < numPulseWaves; ++pulseWaveNo) {
          grd.addColorStop(pulseStart, starDarkColor);
          var nextPulse = pulseStart+1/(2.0*numPulseWaves);
          if (nextPulse < 1) {
            grd.addColorStop(pulseStart+1/(2.0*numPulseWaves), starBrightColor);
          }
          pulseStart = pulseStart + pulseOffset;
       } 

        grd.addColorStop(1, starBrightColor);



        var angle = 2*Math.PI/numBursts;
        for (var  i = 0; i < numBursts; ++i) {
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen

          ctx.beginPath();
          ctx.moveTo(-starburstWidth, 0);
          ctx.lineTo(0, starburstHeight);
          ctx.lineTo(starburstWidth, 0);
          ctx.closePath();
          ctx.fillStyle = grd; //"rgba(248,252,3,0.8)";
          ctx.fill();
          ctx.rotate(angle);
        }
        ctx.resetTransform();
    }


   var earthCoreRadius = triangleHeight*3;
   function drawBrownCircle(timestamp) {
         var grd = ctx.createRadialGradient(0,0, 0, 0,0, earthCoreRadius);
        grd.addColorStop(0, "rgb(50,0,0)");
        grd.addColorStop(1, "rgb(105,65,27");


        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  earthCoreRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }

    var numTrees = 64;
    var trunkTop = earthCoreRadius*1.1;
    var treeRadius = triangleHeight/6;
    var leavesPerTree = 30;
    var leafDrawRadius = 4;
    var trees = [];

    // the trees will start small, then grow, then turn orange, then leaves fall?
    var treeColorBase = {
      'r' :38, 'g': 99, 'b': 12
    }
    function fudgeColor(base, colorIndex) {
      var baseNum = base[colorIndex];
      return  (Math.floor((baseNum + (baseNum * 0.2 * Math.random())))).toString();
    }

    function makeTreeColor() {
        return 'rgb('+fudgeColor(treeColorBase, 'r')+','
                     +fudgeColor(treeColorBase, 'g')+','
                     +fudgeColor(treeColorBase, 'b')+')';
    }

    function makeLeaf() {
      var leafRadius = Math.random()*treeRadius;
      var leafAngle = Math.random()*Math.PI*2;
      return {
        'color': makeTreeColor(),
        'pos': [ leafRadius*Math.cos(leafAngle), leafRadius*Math.sin(leafAngle)]
      };
    }

    for (var i = 0; i < numTrees; ++i) {
         var targetTrunkLength = (trunkTop - earthCoreRadius);
          trees.push({
        'leaves': [],
        'targetTrunkLength' : targetTrunkLength,
        'targetNumLeaves' : leavesPerTree,
        'trunkLength': Math.random() * targetTrunkLength,
        'leafGap': 100,
        'lastLeaf': 0,
        'lastUpdate': 0
      });
    }
    function updateTree(tree, timestamp) {
        var deltaT = timestamp - tree.lastUpdate;
        if (tree.trunkLength < tree.targetTrunkLength) {
          tree.trunkLength = Math.min(tree.trunkLength + deltaT/500.0,
               tree.targetTrunkLength);
        } else  if (tree.leaves.length < tree.targetNumLeaves && 
            tree.lastLeaf + tree.leafGap < timestamp) {
            tree.leaves.push(makeLeaf());
            tree.lastLeaf = timestamp;
        }
        tree.lastUpdate = timestamp;
    }
    function drawTrees(timestamp) {
        ctx.beginPath();
        // rotate according to the time
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);

        var angle = 2*Math.PI/numTrees;
        for (var  i = 0; i < numTrees; ++i) {
        // CanvasHeights are inverted here; -y axis means go 'up' on the screen
          
          var thisTree= trees[i];
          updateTree(thisTree, timestamp);
          // draw the tree trunk.
          ctx.beginPath();
          ctx.moveTo(0,earthCoreRadius);
          ctx.lineTo(0,earthCoreRadius + thisTree.trunkLength);
          ctx.closePath();
          ctx.strokeStyle = "brown";
          ctx.strokeWidth = '2px';
          ctx.stroke();
          // then draw the leaves;

          for (var leafNo = 0; leafNo < thisTree.leaves.length; ++ leafNo) {
            var thisLeaf = thisTree.leaves[leafNo];
            ctx.beginPath();
            ctx.arc(0+thisLeaf.pos[0], 
                    trunkTop+thisLeaf.pos[1], 
                    leafDrawRadius,
                     0, 2*Math.PI);
            ctx.closePath();
            ctx.fillStyle = thisLeaf.color;
            ctx.fill();

          }
          // draw the next tree
           ctx.rotate(angle);

        }
        ctx.resetTransform();
    }

   var atmosphereRadius = earthCoreRadius*2;
   var purpleOuterFringeColor = "rgba(48,3,252,0.2)";
   function drawBlueCircle(timestamp) {
        var grd = ctx.createRadialGradient(0,0, earthCoreRadius, 0,0, atmosphereRadius);
        grd.addColorStop(0, "#87ceeb");
        grd.addColorStop(1, purpleOuterFringeColor);

        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  atmosphereRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }


   var exosphereRadius = atmosphereRadius*1.1;
   function drawPurpleCircle(timestamp) {
        var grd = ctx.createRadialGradient(0,0, atmosphereRadius, 0,0, exosphereRadius);
        grd.addColorStop(0, purpleOuterFringeColor);
        grd.addColorStop(1, "black");
        
        // Fill with gradient
        ctx.resetTransform();
        ctx.translate(CanvasWidth/2.0, CanvasHeight/2.0);
        ctx.beginPath();
        ctx.arc(0, 0,  exosphereRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.resetTransform();
    }


    var numStars = 128;
    var starSpots = [];
    var starRadius = 2;
    for (var i = 0; i < numStars; ++i) {
      var x = Math.random()*CanvasWidth;
      var y = Math.random()*CanvasHeight;
      starSpots[i] = [x,y];
    }
    function drawStars() {
      for (var i = 0; i < starSpots.length; ++i) {
        // Fill with gradient
        ctx.resetTransform();
        ctx.translate(starSpots[i][0], starSpots[i][1]);
        ctx.beginPath();
        ctx.arc(0, 0,  starRadius, 0, 2*Math.PI);
        ctx.closePath();
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.resetTransform();
      }
    }


    var start = null;
    var breathTimeMs = 5000;
    var cycleTimeMs = breathTimeMs*4;
    function drawAll(timestamp) {
      // Draw in color-reverse order
      drawStars(timestamp);
      drawPurpleCircle(timestamp);
      drawBlueCircle(timestamp);
      drawTrees(timestamp);
      drawBrownCircle(timestamp);
      drawYellowStarburst(timestamp);
      drawOrangeSquares(timestamp);
      drawRedTriangle(timestamp);
      //
        requestAnimationFrame(drawAll);
    }

  
  clearBox();
  window.requestAnimationFrame(drawAll);
  
    
});
</script>
</head>
<body>
  <canvas id="draw-canvas" width="800" height="800"></canvas>
</body>
</html>

